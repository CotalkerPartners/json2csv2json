## json2csv2json
Convert to and from object and csv. This is made using the Node.js Transform stream class.

# Example
In the simplest form, the first row of a .csv like this:
```csv
Name, lastName, Active, Charge
Eduardo, Soto, true, Developer
Edward, Alvarado, true, CTO
```
Maps Initialy to JSONs like this
 ```javascript
{
  Name: Eduardo,
  lastName: Soto,
  Active: true,
  Charge: Developer
}
 ```
The useful feature of this library is the fact that you can nest the row values depending on the header name or on the preprocessing configuration with the use of '{}' to represent objects and '[]' to represent arrays. For example, if I have a column like this:

```csv
ocean{reef}[2]{fish}[1]{name}
Nemo
Dory
Marlin
```
it maps to (or in) an object like this:
 ```javascript
{
  ocean: {
    reef: [
      null,
      null,
      {
        fish: [
          null,
          {
            name: 'Nemo'
          }
        ]
      }
    ]
  }
}
 ```
 In the same manner a stream of objects with that atribute would produce a column with a header name of 'ocean{reef}[2]{fish}[1]{name}'. That header name can be edited and the object attribute can be chosen to be ignored.
 You can also map a given header giving the pre-stream configuration the nesting path in the object using the special notation.

# Configuration CSV2JSON

Headers (or user) generate an internal configuration in the c2j object, which is represented by an object with the attributes of the separator of the .csv (by default is ','), a boolean describing if the file or stream provided has a header row in the first row and an array of objects, each of one representing a specific column of the .csv provided.
This object has the following attributes:
  * columnNum: This is not implemented in this class, but it represents the order of the columns in the csv, it's used in the JSON2CSV mode.
  * read: A boolean that if true the column will be read and if false it'll be ignored by the parser, alternatetively you can ignore a set of values in a column if you don't provide their column config object, and just provide the ones that you want to read, given that this value is true in those provided.
  * type: Represents the data type that the row value will be parsed when mapped to an object (not implemented).
  * headerName: The header name in the provided .csv. It's of utmost importance that this parameter is provided correctly because the mapping in the .csv is made searching for the column marked by this value.
  * objectPath: A string representing the path the value in the column will take once mapped into the object. By default objectPath is equal to headerName but you can edit this changing it in this config. Examples:
    * If you'd like to represent the path of 'Value' (nested in another object) in the object { Attribute: { Subattribute: Value } }, the path is described by the string 'Attribute{Subattribute}'.
    * If you'd like to represent the path of 'Value' (now nested in an array) in the object {Attribute: ['Walue', 'Value']}, the path string is 'Attribute[1]'.
    * In the same manner you can nest indefinetely objects and arrays in this way i.e 'Attribute{Subattribute}[1]{Alias}[2]'.
    * **Hint** The default value of objectPath being equal to the headerName has the advantage that you can edit the headers in the same .csv file so you can skip this part of the config. 

Let's say our csv looks like this. If we provide the headers, the config it's autogenerated for every column, but you can provide your own config if you provide the config object. 

Also you can obtain the config object using the following command:
 ```javascript
c2j.getConfig();
/*
{ 
  separator: ',',
  hasHeader: true,
  rows: [
    {
      rowID: 0,
      read: true,
      type: 'String',
      headerName: 'Name',
      objectPath: 'Name'
    },
    {
      rowID: 1,
      read: true,
      type: 'String',
      headerName: 'lastName',
      objectPath: 'lastName'
    },
    {
      rowID: 2,
      read: true,
      type: 'String',
      headerName: 'Active',
      objectPath: 'Active'
    },
    {
      rowID: 3,
      read: true,
      type: 'String',
      headerName: 'Charge',
      objectPath: 'Charge'
    }
  ]
}
*/
```
This last configuration generates the following internal object structure by default:

```javascript
{
  Name: 'Value',
  lastName: 'Value',
  Active: 'Value',
  Charge: 'Value'
}

```
Modifying the config, using the nesting notaition in the objectPaths like this:

 ```javascript
 
c2j.rows[0].objectPath = 'Name{First}';
c2j.rows[1].objectPath = 'Name{Last}';
c2j.rows[2].type = 'Boolean';

c2j.printConfig();

/*
{ 
  separator: ',',
  header: true,
  rows: [
    {
      rowID: 0,
      read: true,
      type: 'String',
      headerName: 'Name',
      objectPath: 'Name{First}'
    },
    {
      rowID: 1,
      read: true,
      type: 'String',
      headerName: 'lastName',
      objectPath: 'Name{Last}'
    },
    {
      rowID: 2,
      read: true,
      type: 'Boolean',
      headerName: 'Active',
      objectPath: 'Active'
    },
    {
      rowID: 3,
      read: true,
      type: 'String',
      headerName: 'Charge',
      objectPath: 'Charge'
    }
  ]
}*/

```
Reprocess the JSON output structure like this:

 ```javascript
{
  Name: {
    First: 'Value'
    Last: 'Value'
  },
  Active: 'Value',
  Charge: 'Value'
}
 ```
 # Usage csv2json
 
 You can initialize a new instance of the CSV2JSON class providing a string containing **all** the headers in the .csv.
 #**Important: for now you MUST provide in some manner the complete header row regardless if your file has headers or not, if not provided the first row will be utilized as header values to initialize the config**.

 ```javascript
 const CSV2JSON = require('j2c2j').CSV2JSON;
 const fs = require('fs')
 
 const csvPath = 'path/to/csvFile.csv'
 const c2j = CSV2JSON('Name, lastName, Active, Charge');
 ```
 In this last situation you can start editing the autogenerated config object which is a property of the c2j instance.
 If you just wish to parse and config and provided that your .csv file **has** a first row of headers, you can initialize in blank, just call the constructor and then modify c2j's properties:
 
```javascript
  const c2j = CSV2JSON();
  c2j.rows.push({
      rowID: 0,
      read: true,
      type: 'String',
      headerName: 'Name',
      objectPath: 'Name{First}'
    });
```
Or you can input your configurations if you have them in a JSON file with parse or manually:
 
```javascript
  const c2j = CSV2JSON(config = {rows:[
    {
      rowID: 0,
      read: true,
      type: 'String',
      headerName: 'Name',
      objectPath: 'Name{First}'
    },
    {
      rowID: 1,
      read: true,
      type: 'String',
      headerName: 'lastName',
      objectPath: 'Name{Last}'
    },
    {
      rowID: 2,
      read: true,
      type: 'Boolean',
      headerName: 'Active',
      objectPath: 'Active'
    },
    {
      rowID: 3,
      read: true,
      type: 'String',
      headerName: 'Charge',
      objectPath: 'Charge'
    }
  ] 
  });
```
If you'd like to check the resulting object structure or schema from the c2j config:

  ```javascript
  JSON.stringify(c2j.getSchema(), null, 2);
  
  /*
  {
  Name: {
    First: 'Value'
    Last: 'Value'
  },
  Active: 'Value',
  Charge: 'Value'
  }
  
  */
 ```
Once you are sure about that previous step you can start piping the input stream so it can be processed.

```javascript
fs.createReadstream(csvPath)
.pipe(c2j())
.on('data', (data) => {
  console.log(data);
})
.on('error', (err) => {
  console.log(err);
});


/*
{
  Name: {
    First: 'Eduardo',
    Last: 'Soto'
  },
  Active: true,
  Charge: 'Developer'
}

{
  Name: {
    First: 'Edward',
    Last: 'Alvarado'
  },
  Active: true,
  Charge: 'CTO'
}

*/

```

 # Usage json2csv
 
 ```javascript
const jsonPath = 'path/to/file' 

const CSVtoJSON = require('j2c2j').JSONtoCSV

const j2c = JSONtoCSV();

const fs = require('fs');

fs.createReadStream(jsonPath)
.pipe(j2c())
.on('data', (data) => {
  console.log(JSON.stringify(data, null, 2));
})
.on('error', (err) => {
  console.log(err);
});
```
